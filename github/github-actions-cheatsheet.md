# Github Actions Cheatsheet

<!-- tl;dr starts -->

GitHub Actions is a my go-to CI/CD platform that allow you to automate your build, test and deployment pipeline. GitHub Actions syntax are very robust and therefore have high complexity.

<!-- tl;dr ends -->

## Syntax

```sh
# stop workflows from being triggered on 2 events: `push` and `pull_request`
$ git commit -S -m "Update README.md [skip ci]"
$ git commit -S -m "Update README.md [ci skip]"
$ git commit -S -m "Update README.md [no ci]" # shortest
$ git commit -S -m "Update README.md [skip actions]"
$ git commit -S -m "Update README.md [actions skip]"

# use trailer
# it must be included at the end of the commit message and preceded by two empty lines. The consecutive new lines will be removed.
$ git commit -S -m "Update README.md
>
>
skip-checks: true" # or skip-checks:true

# using interactive code editor is better
```

```yml
name: One-size-fit-all syntax file

# 1. Step 1: pick a Workflow Template
# 2. Step 2: choose WHEN your workflow runs
# 3. Step 3: choose WHERE your workflow runs
# 4. Step 4: choose WHAT your workflow does

# GitHub Actions context uses expression syntax ${{ foo.bar }}
# foo.bar - property dereference syntax (I used to call it 'dot notation')
# foo['bar'] - index syntax
run-name: ${{ github.actor }} is testing out GitHub Actions
on: # when your workflow runs
  # triggers the workflow on push or PR events only for the
  push:
    branches: [$default-branch] # or $protected-branch
  pull_request:
    branches: [$default-branch] # or $protected-branch
  schedule:
    - cron: $cron-daily         # execute at a random point in time today

  # allow manually trigger workflow from the Action tab in Web UI
  workflow_dispatch:

  # make workflow become reusable
  workflow_call:
    # map the workflow outputs to job outputs
    outputs:
      firstword:
        description: "The first output string"
        value: "${{ jobs.test_output.outputs.mock_output_1 }}"
      secondword:
        description: "The second output string"
        value: "${{ jobs.test_output.outputs.mock_output_2 }}"

# workflow-level env var
env:
  env_var: ${{ vars.CONFIG_ENV }} # set workflow-level env var with the value of a configuration env var
  DAY_OF_WEEK: Monday # dictionary syntax, data type is parsed

permissions:
  # use cases: check out code from the repo, read files for test or build
  contents: read

jobs:
  test_env:
    runs-on: ubuntu-latest
    # job-level env var
    env:
      greeting: Hello
    steps:
      - name: "It's Monday, say Hi"
        # ${{}} is optional, but if specified, enclosed ALL statement
        # determine whether a job or step is sent to the runner or not
        if: ${{ env.DAY_OF_WEEK == 'Monday' }}
        # `run:` command is processed by a runner
        # => runner env vars are processed by runner as well, or more specifically, by the shell
        # => runner env vars can't be used in parts of the workflow that're processed by GitHub Actions
        # therefore the variable substitution syntax must match the corresponding shell
        # other instructions, are processed by GitHub Actions, not by runner
        # GitHub Actions interpolates the "contexts" (i.e replaced by a string) before sending the job to the runner.
        run: echo "${greeing} ${first_name}. Today is ${DAY_OF_WEEK}" # or ${{ env.DAY_OF_WEEK }}
        env:
          # step-level env var
          first_name: John

  test_action_checkout:
    runs-on: ubuntu-latest
    steps:
      # ====================================================================== #
      # actions/checkout@v4                                                    #
      # ====================================================================== #
      # `git clone [OPTIONS]` in a nutshell
      # Docs: https://github.com/actions/checkout

      - name: Checkout
        uses: actions/checkout@v4
        #with:
        #   repository:         # repo owner/name, e.g. `actions/checkout`.
        #                       # Def: ${{ github.repository }}
        #   ref:                # the branch, tag, SHA to checkout.
        #                       # Def: default branch
        #   token:              # GitHub PAT used to fetch the private repo, generated by a service account with the least permissions and scopes.
        #                       # Def: ${{ github.token }}
        #   ssh-key:            # SSH key used to fetch the private repo, managed by a service account with least permissions
        #   ssh-known-hosts:    # Known hosts in addition to the user and global host key database.
        #   ssh-strict:         # Whether to perform strict host key checking.
        #                       # Def: true
        #   ssh-user:           # The user to use when connecting to the remote SSH host.
        #                       # Def: git
        #   persist-credentials:# Whether to configure the token or SSH key with the local git config
        #   path:               # relative path under $GITHUB_WORKSPACE to place the repository
        #   clean:              # Whether to execute `git clean --ffdx` or `git reset --hard HEAD` when fetching.
        #                       # Def: true
        #   filter:             # Partially clone against a given filter.
        #                       # Def: null
        #   sparse-checkout:    # Do a sparse checkout on given patterns, separated with newlines.
        #                       # Def: null
        #   sparse-checkout-cone-mode:  # whether to use cone-mode when doing a sparse checkout.
        #                               # Def: true
        #   fetch-depth:        # number of commits to fetch. 0=all.
        #                       # Def: 1
        #   fetch-tags:         # Whether to fetch tags.
        #                       # Def: false
        #   show-progress:      # Whether to show process status output when fetching.
        #                       # Def: true
        #   lfs:                # Whether to download Git-LFS files.
        #                       # Def: false
        #   submodules:         # "true"=checkout submodules, "recursive"=checkout submodules recursively
        #   set-safe-directory: # Whether to add repository path as safe.directory for Git global config.
        #                       # Def: true
        #   github-server-url:  # The base URL for the GitHub instance that you are trying to clone from.
        #                       # Def: https://github.com

  test_strategy:
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    runs-on: ${{ matrix.os }}
    steps:
      # ...

  test_output:

    outputs:
      # mapping job outputs to step outputs
      mock_output_1: ${{ steps.mock-step-1.outputs.firstword }}
      mock_output_2: ${{ steps.mock-step-2.outputs.secondword }}

    steps:

      # map job outputs to step outputs
      - name: Output firstword
        # NOTE: id naming convention is kebab-case
        id: mock-step-1
        run: echo "firstword=hello" >> ${GITHUB_OUTPUT}

      - name: Output second word
        id: mock-step-2
        run: echo "secondword=world" >> ${GITHUB_OUTPUT}

  test_upload_artifacts:
    # create variables in a single job definition
    # automatically create multiple job runs, each run use 1 value
    runs-on: ubuntu-latest
    strategy:
      matrix:
        test-group: [1, 2]
        node: [18, 20]
    steps:

      # ====================================================================== #
      # actions/upload-artifacts@v4
      # ====================================================================== #

      # Docs: https://github.com/actions/upload-artifact
      # The upload artifact action saves files and directories from your workflow run so they can be:
      # - Downloaded later in the same workflow (by other jobs).
      # - Downloaded after the workflow completes (from the GitHub Web UI).
      # - Shared between different jobs in the same workflow.

      - name: Create logs
        run: echo "Mock test logs" > test-job-${{ strategy.job-index }}.txt

      - name: Upload logs
        id: upload-logs
        uses: actions/upload-artifacts@v4
        with:
          name: Build log for job ${{ strategy.job-index }}
          path: test-job-${{ strategy.job-index }}.txt # file, dir, wildcard. Required
          compression-level: 9        # 0-9, def=6
          if-no-files-found: "error"  # warn, error, ignore, def=warn
                                      # "warn"=output warning, run even failed,
                                      # "error"=fail with a an error message
                                      # "ignore"=do not output any warnings/errors
          retention-days: 90          # 1-90, def=repo's setting
          overwrite: true             # true=overwrite existing name artifact with matching name
                                      # false=action fail if artifact with matching name existed
                                      # def=false
          include-hidden-files: false # whether to include hidden files matched by `path:` directive
                                      # def=false
        # Output:
        # artifact-id
        # artifact-url
        # artifact-digest

      # ====================================================================== #
      # actions/download-artifact@v4                                           #
      # ====================================================================== #

      # Docs: https://github.com/actions/download-artifact
      # The download artifact action can be used to download artifacts that have been uploaded via upload-artifact-v4

      - name: Download logs
        uses: actions/download-artifact@v4
        with:
          name: Build log for job ${{ strategy.job-index }}         # mutex with `artifact-ids:`
          artifact-ids: ${{ steps.upload-logs.output.artifact-id }} # Comma-separated support
          path: "/tmp"      # destination path, support ~
                            # Def=$GITHUB_WORKSPACE
          #pattern:         # glob pattern matching the artifacts
          #                 # Ignored if `name:` is used
          #merge-multiple:  # "true"=put multiple matching artifacts into the same dir
          #                 # "false"=each artifact lives in its own dir
          #                 # def=false
          #github-token:    # authenticate when downloading artifacts from another repo
          #                 # def=${{ github.token }}
          #repository:      # <repository_name>/<owner_name>
          #                 # def=${{ github.repository }}
          #run-id:          # The id of the workflow run where the desired download artifact was uploaded from     # def=${{ github.run_id }}

      # ====================================================================== #
      # actions/cache@v4                                                       #
      # ====================================================================== #
      # Docs: https://github.com/actions/cache

      - name: Get Date
        id: get-date
        run: |
          echo "date=$(/bin/date -u "+%Y%m%d")" >> $GITHUB_OUTPUT
        shell: bash

      # IMPORTANT: find your tool's way of caching here: https://github.com/actions/cache?tab=readme-ov-file#implementation-examples
      - name: Cache Primes
        id: cache-primes
        uses: actions/cache@v4
        with:

          # multi-line list of files, dirs, wildcard patterns
          path: |
            prime-numbers
          # force restore stale cache and create new cache using unique 'key:'
          key: ${{ runner.os }}-primes-${{ github.run_id }}                 # run id approach
          key: ${{ runner.os }}-primes-${{ steps.get-date.outputs.date }}   # time-based approach

          # if use package file's hash and expect partial key matching
          # install missing/updated dependencies (e.g. NPM, PIP, ...)
          key: ${{ runner.os }}-primes-${{ hashFiles('**/lockfiles') }}
          # restore-keys: |
          #   ${{ runner.os }}-primes         # restore stale cache if no cache hit occurred for `key:`i
          #fail-on-cache-miss: false        # fail if cache entry is not found
          #lookup-only: true                # check if cache entry exists and skips download

        # only one output: cache-hit
        # true when cache hit
        # false with using `restore-keys:` or no cache is restored

      - if: ${{ steps.cache-primes.outputs.cache-hit != "true" }}
        name: Generate Prime Numbers
        run: /generate-primes.sh -d prime-numbers

      - name: Use Prime Numbers
        run: /primes.sh -d prime-numbers

      # Caching strategy:
      #
      # - First, search for cached assets whose name matches `key:`.
      # - If there's a match, cache hit. The action restores the cached dirs and files to `path:`
      # - If no exact match is found, cache miss. A new cache is surely created if the job completes.
      # - Cache miss doens't mean downloading everything from scratch, you can search cached assets whose name matches one of the prefix-matched keys specified in `restore-keys:`
      # - However, if you want everything to be up-to-date, don't use `restore-keys:`

      # ====================================================================== #
      # bats-core/bats-action@3.0.0 + action/cache@v4                          #
      # ====================================================================== #

      - name: Setup BATS and BATS libs
        id: setup-bats
        uses: bats-core/bats-action@3.0.0
        timeout-minutes: 10
        with:
          # def="/usr/lib/bats-<lib-name>"
          # to enable caching Bats libs, installed them inside HOME directory
          support-path: "${{ github.workspace }}/tests/test_helper/bats-support"
          assert-path: "${{ github.workspace }}/tests/test_helper/bats-assert"
          file-path: "${{ github.workspace }}/tests/test_helper/bats-file"

      - name: Test script.sh
        shell: bash
        env:
          BATS_LIB_PATH: ${{ steps.setup-bats.outputs.lib-path }}
          TERM: xterm
        run: bats tests/test_script.sh

      - name: Test template.sh
        env:
          TERM: xterm
          SCRIPT_NAME: template.sh
        run: bats tests/test_script.sh
```

## Overview

ONE repository can have ONE OR MORE workflows.

When ONE **event** occurs in the repository, ONE **workflow** is triggered.

ONE workflow contains ONE OR MORE **jobs**, which can be run in sequential order or in parallel.

ONE job is run inside its own ONE **runner**, which is a virtual machine or a container.

ONE job consists of ONE OR MORE **steps** that either run a **script** that you defined or an **action** whic is a reusable extension.

<!-- TODO: insert Mermaid diagram here -->

1. [**Workflow**](#workflow)
1. [**Event**](#event)
1. [**Job**](#job)
1. [**Runner**](#runner)

## Workflow

A YAML file inside `.github/workflows` directory.

```yml
# ci/django.yml
# cre: https://github.com/actions/starter-workflows/blob/main/ci/django.yml
name: Django CI

on:
  push:
    branches: [$default-branch]
  pull_request:
    branches: [$default-branch]

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      max-parallel: 4
      matrix:
        python-version: [3.7, 3.8, 3.9]

    steps:
      - uses: actions/checkout@v4
      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v3
        with:
          python-version: ${{ matrix.python-version }}
      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      - name: Run Tests
        run: |
          python manage.py test
```

An optional corresponding JSON file `.properties.json` containing metadata about the workflow can be supplied. If you chose to publish the workflow on GitHub Marketplace, the metadata will be displayed in the GitHub Web UI:

```jsonc
// django.properties.json
// cre: https://github.com/actions/starter-workflows/blob/main/ci/properties/django.properties.json
{
  // the name shown in onboarding, unique within the repo
  "name": "Django",

  // use case summarization
  "description": "Build and test a Django project",

  // <project_root>/icons/django.svg
  "iconName": "django",

  // Choose a subset from here: https://github.com/actions/starter-workflows?tab=readme-ov-file#categories
  "categories": ["Continuous Integration", "Python", "Django"],

  // hide the template from users, unless user add URL Query parameter `preview=true`
  // remove it to publish the template
  // e.g. https://github.com/<owner>/<repo_name>/actions/new?preview=true
  "labels": ["preview"]
}
```

**Workflow Template:** Creating a workflow from scratch is too much of a hassle, choose a [workflow template](https://github.com/actions/starter-workflows/tree/main). GitHub analyzes the existing code in your repository to extract the language and framework then recommands workflows based on them.

There are 5 high-level categories for workflow template:

1. [CI](https://github.com/actions/starter-workflows/blob/main/ci)

   - Build and test.

1. [CD](https://github.com/actions/starter-workflows/blob/main/deployments)

   - Build container image and deploy on major cloud providers' services.
   - Publish packages to repository/registry (DockerHub, NPM, PIP, Java, ...)

1. [Code Scanning](https://github.com/actions/starter-workflows/blob/main/code-scanning).

   - Scan commits/PRs with static analysis tools (CodeQL, Snyk, Dependabot, ...)

1. [Automation](https://github.com/actions/starter-workflows/blob/main/automation).

   - Add labels to GitHub Issues.
   - Closing inactive Issues.
   - Comment on an issue when a label is added.
   - Schedule an issue creation.
   - ...

1. [GitHub Pages](https://github.com/actions/starter-workflows/blob/main/pages)

You can use template workflows as-is, or use them as a starting place to create a custom workflow for your organization.

Anyone with WRITE access to the organization `.github` repository can set up a workflow template.

Advanced workflow features:

- Storing secrets.
- Creating dependent jobs.
- Using a matrix.
- Caching dependencies.
- Using databases and service containers.
- Using labels to route workflows.
- Reusing workflows.
- Security hardening for workflows.
- Using environments.

## Context

Pre-defined special objects storing information about workflow runs, variables, runner environments, jobs, steps.

They can be accessed using expression syntax: `${{ foo.bar.baz }}`. The dot notation indicating that you're accessing information of the directives `.bar`, `.baz`.

Certain contexts' values have their values taken from untrusted source, be careful when executing them:

- `github.*`: workflow runs, triggering event

  ```yml
  github.actor
  github.ref
  github.ref_type
  github.repository
  github.repository_owner
  github.run_id
  github.workflow
  ```

- `env.*`: variable set inside a workflow, a job or a step.

  ```yml
  env.<env_name>
  ```

- `vars.*`: variable set inside repository, organization, environment levels.

  ```yml
  vars.MOCK_ENV
  ```

- `job.*`: info about current job

  ```yml
  job.services.<service_id>.id
  job.services.<service_id>.network
  job.services.<service_id>.ports
  ```

- `jobs.*`: stored outputs of prior executed jobs. Good for create reusable workflow. A workflow template is a reusable workflow.

  ```yml
  jobs.<job_id>.result                      # success, failure, cancelled, skipped
  jobs.<job_id>.outputs.<output_name>       # <output_name> and its value is written in $GITHUB_OUTPUT
  ```

- `steps.*`: info about all the steps that run in the current job.

  ```yml
  steps.<prev_step_id>.outputs.<output_name> # <output_name> and its value is written in $GITHUB_OUTPUT
  ```

- `runner.*`: info about the runner that is executing the current job.

  ```yml
  runner.name
  runner.os
  runner.arch
  runner.temp
  ```

- `secrets`: sensitive credentials information that are required for a workflow to run.

  ```yml
  secrets.GITHUB_TOKEN
  secrets.NPM_TOKEN
  secrets.SUPER_SECRET
  ```

- `strategy`: info about `matrix`.

  ```yml
  strategy.job-index
  strategy.job-total
  strategy.max-parallel
  ```

- `matrix`: info about running multiple jobs with different input parameters.

  ```yml
  matrix.<property_name>
  ```

- `needs` - the outputs of all jobs that are defined as dependencies of the **current job**.
- `inputs` - the inputs of a reusable or manually triggered workflow.

Two syntax to access context information:

- Index syntax: `${{ github['repository'] }}`
- Property dereference syntax/Dot notation: `${{ github.repository }}`

## Variables

- Store and re-use non-sensitive config info.
- Commands in `run:` key inside each Step of a Workflow can create, read, modify variables.
- Define single workflow custom variables via `env:` key
- Define multiple workflows custom variables via Web UI portal at the organization, repository, environment level.
- Variables render unmasked in build outputs to which can be read by anyone have access. Use `secrets.*` variable to mask them.
- **Context is not the only source of information**. Default environment variables: `GITHUB_*` or `RUNNER_*` exists only on the runner that is executing your job.

```yml
name: Greating
on:
  workflow_dispatch:

jobs:
```

### Configuration environment variables

They can be created at:

- Repository-level.
- Environment-level.
- Organization-level.

They are available in the `vars:` context.

Limits:

- 48KB max
- 1000 organization variables.
- 500 variables/repository.
- 100 variables/environment.

### Default environment variables

- Variables containing metadata that're set by GitHub, available to every step in a workflow.
- Can't be accessed through `env.*` context but accessible through `github.*` context. E.g. `${GITHUB_REF}` -> `${{ github.ref }}`
- Default env vars are unable to overwrite (except `CI`, not all occasion though)
- Actions should use variables to access filesystem rather than using hardcoded file paths.

Some notable default env vars:

```sh
$GITHUB_REF               # fully-formed ref of the branch/tag that triggered the
                          # workflow run
                          # for push event, branch: refs/heads/<branch_name>
                          # for push event, tag:    refs/tags/<tag_name>
                          # for pull_request event: refs/pull/<pr_number>/merge

$GITHUB_REF_NAME          # the short ref name of the branch/tag that triggered the
                          # workflow run
                          # push event: <branch_name>/<tag_name>
                          # pull_request event: <pr_number>/merge

$GITHUB_REF_TYPE          # the type of ref that triggered the workflow run
                          # valid values are branch or tag

$GITHUB_REPOSITORY        # owner + repo name
$GITHUB_REPOSITORY_ID     # owner + repo name
$GITHUB_REPOSITORY_OWNER  # owner name
$GITHUB_RUN_ID            # unique number for each workflow
$GITHUB_SHA               # the commit SHA that triggered the workflow
$GITHUB_WORKFLOW          # the name of the workflow
```

## Event

An event is a specific activity in a repository that triggers a **workflow** run:

- A Pull Request is created.
- A GitHub Issue is opened
- A commit is pushed to a repository.
- ... many more

Every non GitHub-specific events:

- Events that occur outside of GitHub and trigger a `repository_dispatch` event on GitHub.
- Scheduled times
- Manual.

### Job

ONE job consists of ONE OR MORE steps in a workflow that's executed on the same runner.

ONE step is either a shell script, or an action.

Steps are executed in order, dependent on each other.

Steps can share each other's data since they're running on the same runner.

By default, jobs have no dependencies and run in parallel. Sequential jobs is when a job can take a dependency on another job and it waits for the dependent job to complete before running.

E.g. Multiple build jobs for different architectures run a parallel and a packaging job that depends on those builds run after they complete successfully.

### Actions

It's a custom application for GitHub Actions platform that performs a complex but frequently repeated task.

Use an action to help reduce the amount of repetitive code that write in your workflow files.

Examples:

- Pull GitHub repository.
- Set up toolchain for build environment.
- Set up authentication to cloud provider.

### Runner

It's a server that runs your workflows when they're triggered.

ONE runner can run ONE job at a time.

GitHub provides Ubuntu Linux, MS and macOS runners to run workflows. Each workflow run executes in a fresh virtual machine.

You can host your own runners if you need a different OS, but 95% of use cases can be fulfilled with above runners.

## Reference

- [Accessing Contextual Information](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/accessing-contextual-information-about-workflow-runs)
- [Caching dependencies to speed up workflows, GitHub Docs](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/caching-dependencies-to-speed-up-workflows)
